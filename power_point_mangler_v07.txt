#! /bin/bash


# Audit Trail
# Version 7 Try GoogleDrive instead of OneDrive
# Version 6 Rework to handle Jonathan's Python based approach
# Version 5 19 Feb 2020 Windows version must handle spaces in file names and struggled with CR/LF line ends
# Version 4 19 Feb 2020 Tidied up BADFILE flag.
# Version 3 16 Jan 2015 mrj Added logging function 
# Version 2 3 Nov 2014 mrj Added revised main loop with updates from Peter Flynn
# Version 1 31 Oct 2014 mrj Original. This is a bash shell wrapper around some code created by Peter Flynn
CODE_DIR="/mnt/c/Users/malco/OneDrive/XSLT stuff/access-ppt/transform"		#where the python lives
CODE_FILE="doit.py"

#WORK_DIR="/mnt/c/Users/malco/OneDrive/XSLT stuff/User Directories/" #OneDRive will export this directory
WORK_DIR="/mnt/c/Users/malco/Google Drive/XSLT share/User Directories/" #GoogleDrive will export this directory

INPUT_DIR="input_folder"	#user will put files in this folder	
OUTPUT_DIR="output_folder"	#results will apper here
ERROR_DIR="error_folder"
DONE_DIR="done_folder"		#files will be put here once processed
LOG_DIR="log_folder"
#CONFIG_DIR="/home/malcolm/config"
TEST_FILE="Forms-cjforms-WWC-2014.pptx"
#Files will be dropped in via OneDrive so we need to ensure that they have arrived in full before mangling them
function is_file_stable
	{
	let LOOPCOUNT=0 #don't wait indefinitely
	let SIZE=0 
	let OLDSIZE=-1	# set up two measures  of file size, initially different
	PROCESS_FILE_NAME=$WORK_DIR$INPUT_DIR/$1
	#echo $SIZE ; echo $OLDSIZE
	echo "File is $PROCESS_FILE_NAME"
	while [ $OLDSIZE -ne $SIZE ] # until the file is stable we loop around
		do
		{
		OLDSIZE=$(ls -al "$PROCESS_FILE_NAME"  | awk '{ print $5 }' )	#how big is the file
		sleep 1									#let's wait awhile
		SIZE=$(ls -al "$PROCESS_FILE_NAME"  | awk '{ print $5 }' )	#how big is the file
		(( LOOPCOUNT++ ))
		if [ $LOOPCOUNT -gt 60 ] 
			then
			{
			echo "Timed out waiting for file $1 to become stable" >> "$LOGFILE"
			break
			}
		fi
		}
		done
	}
function is_file_power_pig
        {
                echo "$1 being processed by is_file_power_pig" >> "$LOGFILE"
				let BADFILE=1					#assume dodgy
                case $1 in
                        #*' '*) echo "Spaces not allowed in filename"  >> "$LOGFILE"
				#mv "$WORK_DIR/$INPUT_DIR/$1" "$WORK_DIR/$ERROR_DIR" ;;
                        *.pptx) echo "File is PPTX file, OK to process" >> "$LOGFILE" 
				let BADFILE=0 ;;		#happy
                        *.ppt) echo "File is PPT file can only process PPTX files"  >> "$LOGFILE"
				let BADFILE=1          ;;
                        *) echo "Unknown file type, cannot process" >> "$LOGFILE"
				mv "$WORK_DIR/$INPUT_DIR/$1" "$WORK_DIR/$ERROR_DIR" ;;
                esac
        }
function is_directory_empty
	{
	let EMPTY_DIR=0		#set flafg to show directory empty
	echo "Checking directory $WORK_DIR/$INPUT_DIR"
	EMPTY_DIR=`ls -A "$WORK_DIR"/"$INPUT_DIR"  | wc -l`
	}
#Version 6 Major changes here to adopt Jonathan's approach	
function run_process_loop
	{
	echo "Enter process loop with "$WORK_DIR/$INPUT_DIR/$1" logging to "$LOGFILE" "
	python3 "$CODE_DIR/$CODE_FILE"  \
    "$WORK_DIR/$INPUT_DIR/$1" \
	| cut -d"," -f2- \
	>> "$LOGFILE"
	echo "Finished process loop with $FIRST_FILE"
	#FILE=`basename "$FIRST_FILE" .pptx`	#lop off the file extension
	mv "$WORK_DIR/$INPUT_DIR/$1" "$WORK_DIR/$DONE_DIR"	#put file i done folder. This tells the user we are done and stops us looping
	}
	


#here is the main indefinite loop for the daemon process
while true		#always true, always loop
do
	{
	is_directory_empty	#have we anything to do?
	if [ $EMPTY_DIR -eq 0 ]	#0 means no we can idle
		then
		{
		#echo "Sleeping, directory empty"
		sleep 10		#go to sleep for a while
		}
		else
		{
		FIRST_FILE=`ls "$WORK_DIR$INPUT_DIR" | head -1`
		LOGFILE=$WORK_DIR/$LOG_DIR/$FIRST_FILE.log	#create a log file
		touch "$LOGFILE"				#create a log file
		echo "File $FIRST_FILE is at head of process queue" > "$LOGFILE"
		is_file_power_pig "$FIRST_FILE"	#if it's not right chuck it in the error queue		i
		echo "BADFILE=$BADFILE, 0 is OK, anything else dodgy" >> "$LOGFILE"
		if [ $BADFILE -ne 0 ]
			then
				{
				echo "We detected $FIRST_FILE was dodgy" >> "$LOGFILE"
				sleep 1			#do nothing much
				}
				else
				{
				echo "Let's process $FIRST_FILE" >> "$LOGFILE"
				is_file_stable "$FIRST_FILE"		#just check it's nort still being written
				run_process_loop "$FIRST_FILE" #this is where the real work is done!
				}	
		fi	
		}
	fi
	}
done

